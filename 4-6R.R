# ПРАКТИКА 4
#ВЕКТОРЫ
#В редакторе кода с помощью функции конкатенации создать векторыразных типов. Проверить на этих векторах как работают различныеарифметические и логические операции.
# 1   создание векторов
new_vector_numerik <-c(6)
new_vector_character <- c("test")
new_vector_factor <- c(factor(5))
new_vector_logical <- c(TRUE)
#проверка типа 
class(new_vector_numerik)
class(new_vector_character)
class(new_vector_factor)
class(new_vector_logical)
is.vector(new_vector_numerik)
is.vector(new_vector_character)
is.vector(new_vector_factor)
is.vector(new_vector_logical)
#арифметические операции
new_vector_numerik + 2
new_vector_numerik ^ 2
new_vector_numerik %% 2
#лоические операции
new_vector_numerik <= 5
new_vector_logical == FALSE
# 2 Создать три целочисленные переменные и одну логическую переменную,в которую нужно сохранить результат проверки (значение TRUE илиFALSE): действительно ли сумма первых двух созданных чисел больше,чем третье число. 
first <- 5
second <- 5
third <- 6
result_logik <- (first + second) > third
# 3 Создать переменную, состоящую из чисел, идущих в следующемпорядке: сначала от 7 до 7134, затем от 8537 до 9642.
test_1_3 <- c(7:7134 , 8537 : 9642)
#4 Создать переменную vector1, состоящую из 10 целых чисел. Создатьновую переменную, в которой будут сохранены 4, 7, 3, 10, 5 элементывектора vector1
vector_1 <-(10:20)
new_vector_1 <- vector_1[c(4,3,7,10,5)]
# 5 . Создать переменную Sum_vec суммы всех элементов вектора vector1,которые меньше 14.
sum_vector1 <- vector_1[vector_1 < 14]
x <- sum(sum_vector1)
#ФАКТОРЫ
#1 Создать текстовый (character) вектор lev_obr, состоящий изНЕСКОЛЬКИХ значений уровней образования ("начальное", "среднее",«средне-специальное», «высшее» и т.д.), расположенных в произвольномпорядке
lev_obr <- c('начальное','среднее','средне-специальное','высшее', 'начальное' , 'начальное' , 'высшее')
#2 Узнать является ли переменная lev_obr вектором
is.vector(lev_obr)
#3 Узнать является ли переменная lev_obr текстовой.
is.character(lev_obr)
#4 Посмотреть структуру вектора lev_obr.
str(lev_obr)
#5 Посмотреть таблицу с частотами встречаемости значений переменнойlev_obr
table(lev_obr)
#6  Сделать переменную lev_obr факторной.
lev_obr_f<-factor(lev_obr)
is.factor(lev_obr_f)
#7 Исследовать структуру полученного вектора.
str(lev_obr_f)
#8 . Упорядочить уровни факторной переменной от самого низкого уровня образования к самому высокому из указанных в векторе lev_obr.
lev_obr_o <- ordered(lev_obr, levels= c ("начальное", "среднее", "средне-специальное", "высшее")) 
lev_obr_o
#9 Создать вектор (текстовый) new_vector для категорийной переменной,2уровни которой можно упорядочить. Тему выбрать самостоятельно изсферы бизнеса.
new_vector <- c('ректор', 'асистент','преподаватель','зав.кафедры','студент')
new_vector <- factor(new_vector)
is.factor(new_vector)
new_vector <- ordered(new_vector, levels= c ('студент', 'асистент','преподаватель','зав.кафедры','ректор'))
new_vector[1:2,drop= TRUE]
new_vector
# 3 Матрицы
#Создать матрицу mtx размера � × �, состоящую из произвольных чисел.Значения m и n взять из табл. 2.1 (№ – номер студента в списке группы).
tt_matrix <- 1:36
dim(tt_matrix) <- c(6,6)
#2. Посмотреть структуру матрицы mtx.
str(tt_matrix)
#3. Узнать количество столбцов матрицы mtx. 
nrow(tt_matrix)

#4 Присвоить столбцам и строкам имена.
rownames(tt_matrix) <- c("rowname1","rowname2",'rowname3','rowname4','rowname5','rowname6')
colnames(tt_matrix) <- c("colname1","colname2","colname3","colname4","colname5","colname6")
#5 Транспортировать матрицу, сохранить её в новой переменной mtx1
mtx1 <- t(tt_matrix)
#6 Создать новую переменную mtx2, которой присвоить элемент, стоящий на пересечении 2 строки и 3 столбца.
mtx2 <-  tt_matrix[2,3]
#7. Выбрать из матрицы mtx второй и третий столбцы.
tt_matrix[,c(2,3)]

#8. Присвоить новой переменной mtx3 значения первой строки элементовматрицы mtx, исключая элементы, стоящие во втором и третьемстолбцах.
mtx3 <- tt_matrix[1,-c(2,3)]
#9. Выбрать из матрицы mtx1 второй столбец.
mtx1[,2]
#10. Выбрать из матрицы mtx1 все элементы, кроме второй строки.
mtx1[-2,]
#11. Узнать количество строк и столбцов матрицы mtx.
nrow(tt_matrix)
ncol(tt_matrix)
#12. Узнать количество строк матрицы mtx1.
nrow(mtx1)
#4 СПИСКИ
#1. Создать произвольный список sps, состоящий из 7 элементов разного типа, в том числе list.
sps <- list(factor('fac'),'char', 1:10 ,FALSE,NA,list(TRUE,2,'blablabla'))
#2. Выбрать 3-й элемент списка с использованием квадратных скобок и сиспользованием двойных квадратных скобок.
sps[3]
sps[[3]]
#3. Присвоить элементам списка sps произвольные имена.
names(sps) <- c('one','two','three','four','five','six')
#4. Выбрать 5-ый элемент списка sps с использованием имён элементов.
sps['five']
# ПРАКТИКА 5

# 1  Просмотреть весь список доступных, встроенных в R, наборов данных: 
library(help = "datasets")
# 2 Из табл. 2.2 выбрать набор встроенных данных по варианту, данному преподавателем.
# LifeCycleSavings
#3. Добавить выбранный набор данных в рабочую среду.
LifeCycleSavings
#4. С помощью функции help() изучить информацию о наборе данных.
help(LifeCycleSavings)
#5. Записать набор данных в переменную dats.
dats <- LifeCycleSavings
#6. Вывести на экран первые шесть строк таблицы данных dats.
head(dats)
#7. Посмотреть первых n строк таблицы dats (n = вариант задания+1).
head(dats,7)
#8. Вывести в консоль последние шесть строк таблицы данных dats.
tail(dats)
#9. Посмотреть последние n строк данных dats
tail(dats,1)
#10. Посмотреть всю таблицу dats двумя способами: используя командуView(); используя окно Environment.
View(dats)
#11. Изучить структуру данных dats.
str(dats)
#12. Посмотреть названия переменных набора данных dats.
names(dats)
#13. Вывести статистику dats, используя функцию summary().
summary(dats)
#14. Создать новый вектор Name, состоящий из названия столбцов таблицыdats.
Name <- names(dats)
#15. Создать вектор my_vector, состоящий из значений любого числового столбца таблицы dats.
my_vector <-dats$sr
#16. Найти среднее значение переменной my_vector.
mean(my_vector)
#17. Посмотреть статистику переменной my_vector с помощью функцииsummary().
summary(my_vector)
#18. Добавить в таблицу dats новую переменную, используя оператор $,следующим образом: новый столбец должен состоять из значенийвыбранного столбца (студент выбирает самостоятельно), умноженного наn (n=вариант задания+1).
dats$sr_on2 <-dats$sr * 2
#19.Создать в таблице dats столбец, состоящий из одних нулей.
dats$zeros <- 0
#20.Создать в dats столбец нумерации строк.
dats$numrows <- 1:nrow(dats)
#21.Создать новую таблицу dats1, присоединив к таблице данных dats новыйстолбец следующим образом:
#21.1. создать столбец с таким же числом строк, как в таблице dats;
nov <- c(rep(1:nrow(dats)))

#21.2. присоединить созданный столбец к таблице dats.
dats1<- data.frame(dats,nov)
#22.Удалить переменную (студент выбирает самостоятельно) из набораданных dats1.
dats1$zeros <- NULL
#23. Узнать размерность таблицы dats1.
dim(dats1)
#24.Определить количество столбцов в таблице dats1.
ncol(dats1)
#25.Узнать количество строк в таблице dats1.
nrow(dats1)
#26.Отобрать нужные переменные n1,… ,n11 в таблице данных dats1(n1,…,n11 задать самостоятельно, учитывая, что n1, n2, n3, n7, n8, n9 недолжны превышать количество столбцов в наборе данных dats1, а n4, n5,n6, n10, n11 – количество строк, значения могут повторяться):
#26.1. n1, n2 и n3 столбцы, используя номера колонок (обернув индексы в вектор);
n1 <- dats1[,c(1)]
n2 <- dats1[,c(2)]
n3 <- dats1[,c(3)]
#26.2. используя имена колонок (выбрать самостоятельно любые двепеременные).
dats1[1,c('sr',"sr_on2")]
#27.Отобрать n4, n5, n6 строки в данных dats1.
n4 <- dats1[4,]
n5 <- dats1[5,]
n6 <- dats1[6,]
#28.Отобрать данные в n7, n8, n9 столбцах и n10, n11 строках.
dats1[10:11,7:9]
#29.Отобрать данные из n5-ой строки без тех, которые находятся в n1-ом иn3-ем столбцах.
dats1[-c(1,3),5]
#30.Загрузить в новую переменную univer таблицу данных о приеме студентов в университет Беркли UCBAdmissions.
univer <- UCBAdmissions
#31.Поменять тип данных таблицы univer на dataframe, используя функциюas.data.frame().
univer <-data.frame(univer)
#32.Cоздать переменную FA количества абитуриентов (Freq), поступающих на факультет A (Dept).
temp <- univer[univer$Dept=="A",]
FA <- sum(temp$Freq)
#33.В новый набор данных univer.small сохранить третью, девятую,четырнадцатую и последнюю строчку набора данных univer.
univer.small <- univer[c(3,9,14,nrow(univer)),]

#34.В переменную univer1 сохранить subset данных univer для тех абитуриентов мужчин, которые поступали на факультеты B, C и E вколичестве не меньше 138.
univer1 <- subset(univer,Gender=='Male' & Freq > 138)
# 6 практика
# 1
#1. Загрузить данные из evals.csv в новую переменную dats2.
dats2 <-read.csv("evals.csv", header = TRUE, sep = ",")
#2. В таблице dats2 создать столбец Number нумерации строк.
dats2$Number <- 1:nrow(dats2)
#3. Отсортировать значения столбца Number в порядке убывания.
dats2 <- dats2[order(-dats2$Number),]
#4. Сделать столбец Number первым, остальные столбцы сместить вправо.
dats2<- dats2[,c(22,1:21)]
#5. Удалить из набора данных dats2 переменную Number.
dats2$Number <- NULL
#6. Добавить в код комментарий о том, какую именно переменную удалили.
### удалён столбец Number
#7. Узнать размерность таблицы dats2.
dim(dats2)
#8. В наборе данных dats2 отобрать всех, у кого оценка (score) выше четырёх.
dats2[dats2$score > 4,]
#9. Отобрать из dats2 значения оценок, полученных женщинами.
female <- dats2[dats2$gender == 'female',]
female$score
#10. Получить три колонки данных (на выбор студента), которые касаются только женщин.
female[1:3]
#11. Данные, которые принадлежат женщинам сохранить их в переменную dat_f.
dat_f <- dats2[dats2$gender == 'female',]
#12. Отобрать данные, которые принадлежат мужчинам, сохранить в dat_m.
dat_m <- dats2[dats2$gender == 'female',]
#13.Изучить функции rbind(), cbind().

#14.Соединить переменные dat_f и dat_m по строкам и сохранить впеременную dat_fm.
dat_fm <- rbind(dat_f,dat_m)
#15. Создать переменную dats3, содержащую со второго по седьмой столбцытаблицы dats2.
dats3 <- dats2[,2:7]
#16. Создать переменную dats4 состоящую из столбцов набора данных dat: свосьмого по одиннадцатый.
dats4 <- dats2[8:11]
#17. Соединить переменные dats3 и dats4 по столбцам, сохранить значение впеременную dats5.
dats5 <- cbind(dats3,dats4)
#18. Удалить dats5 из памяти.
rm(dats5)
#19. Одной командой удалить из памяти данные dats3, dats4.
rm(dats3,dats4)
#20. Заменить маленькие буквы на большие в названии любой переменной изтаблицы данных dats2.
names(dats2)[1] <- 'SCORE'
#21. Вывести на экран все названия переменных из набора данных dats2.
names(dats2)
#22.Создать переменную dats6 из 1,4,5,6,7,10 столбцов переменной dats2.
dats6 <- dats2[,c(1,4,5,6,7,10)]
#23.Добавить в таблицу dats6 строку с произвольными переменными.
testing <-  list(1, 'male', "eng", 68, 176, 'lower')
dats6<- rbind(dats6,testing)

#24.Посмотреть последние 6 строк dats6.
tail(dats6)
#25.Избавиться от нечисловых переменных набора данных dats6.
dats6 <- dats6(which(sapply(dats6, is.numeric)))
#26.Создать диаграммы парных зависимостей таблицы dats6.
pairs(dats6)
#27.Изменить имя пятой строки в таблице dats6.
rownames(dats6)[5]<- "Новое"
#28. Удалить из памяти все данные.
rm()
# 2 циклы
#1 Загрузить в переменную cik таблицу данных evals.csv.
cik <-read.csv("evals.csv", header = TRUE, sep = ",")
#2. В наборе данных cik создать новую числовую переменную cik_new,которая в строках содержит единицы, если оценка(score) выше 4. Встроках, где условие не выполняется, поставить нули. Задачу решить сиспользованием конструкции ifelse.
for (i in 1:nrow(cik)){
  if (cik$score[i] > 4){
    cik$cik_new[i] <- 1
  } else  cik$cik_new[i] <-  0
}
#3. Рассчитать скользящее среднее для переменной score набора данных cikс интервалом сглаживания равным 7 (сначала вычисляется среднее дляэлементов с 1 по 7, затем – среднее для элементов со 2 по 8 и т.д.).Результат значений средних сохранить в переменную score_mov.Вектор score_mov можно создать заранее:1 способ. Создать пустой вектор:score_mov <- c()2 способ. Указать длину и тип вектора:score_mov <- numeric(457)
scre_move <- c()
for (i in seq(1,nrow(dat)-7,7)){ 
  scre_move <- rbind(score_mov,mean(cik$score[seq(i,i+6)]))
}
scre_move